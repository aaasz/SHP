//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// LLVMC Configuration Library
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

#include "llvm/CompilerDriver/BuiltinOptions.h"
#include "llvm/CompilerDriver/CompilationGraph.h"
#include "llvm/CompilerDriver/ForceLinkageMacros.h"
#include "llvm/CompilerDriver/Plugin.h"
#include "llvm/CompilerDriver/Tool.h"

#include "llvm/Support/CommandLine.h"
#include "llvm/Support/raw_ostream.h"

#include <algorithm>
#include <cstdlib>
#include <iterator>
#include <stdexcept>

using namespace llvm;
using namespace llvmc;

extern cl::opt<std::string> OutputFilename;

inline const char* checkCString(const char* s)
{ return s == NULL ? "" : s; }

cl::opt<std::string> AutoGeneratedParameter_MT("MT"
, cl::Hidden, cl::desc("Change the name of the rule emitted by dependency generation"));

cl::list<std::string> AutoGeneratedList_D("D"
, cl::Prefix, cl::desc("Define a macro"));

cl::opt<bool> AutoGeneratedSwitch_E("E"
, cl::desc("Stop after the preprocessing stage, do not run the compiler"));

cl::opt<bool> AutoGeneratedSwitch_mdynamic_dash_no_dash_pic("mdynamic-no-pic"
, cl::Hidden, cl::desc("Relocation model: dynamic-no-pic"));

cl::list<std::string> AutoGeneratedList_F("F"
, cl::Prefix, cl::desc("Add a directory to framework search path"));

cl::opt<bool> AutoGeneratedSwitch_pthread("pthread"
, cl::desc("Enable threads"));

cl::list<std::string> AutoGeneratedList_I("I"
, cl::Prefix, cl::desc("Add a directory to include path"));

cl::list<std::string> AutoGeneratedList_Wa_comma_("Wa,"
, cl::Prefix, cl::CommaSeparated, cl::desc("Pass options to assembler"));

cl::opt<std::string> AutoGeneratedParameter_march("march"
, cl::Hidden, cl::desc("A synonym for -mtune"));

cl::list<std::string> AutoGeneratedList_L("L"
, cl::Prefix, cl::desc("Add a directory to link path"));

cl::list<std::string> AutoGeneratedList_framework("framework"
, cl::desc("Specifies a framework to link against"));

cl::list<std::string> AutoGeneratedList_Wo_comma_("Wo,"
, cl::Prefix, cl::CommaSeparated, cl::desc("Pass options to opt"));

cl::opt<bool> AutoGeneratedSwitch_opt("opt"
, cl::desc("Enable opt"));

cl::opt<bool> AutoGeneratedSwitch_S("S"
, cl::desc("Stop after compilation, do not assemble"));

cl::opt<std::string> AutoGeneratedParameter_mcpu("mcpu"
, cl::Hidden, cl::desc("A deprecated synonym for -mtune"));

cl::opt<bool> AutoGeneratedSwitch_m64("m64"
, cl::Hidden, cl::desc("Generate code for a 64-bit environment"));

cl::list<std::string> AutoGeneratedList_Wllc_comma_("Wllc,"
, cl::Prefix, cl::CommaSeparated, cl::desc("Pass options to llc"));

cl::opt<bool> AutoGeneratedSwitch_O0("O0"
, cl::desc("Turn off optimization"));

cl::opt<bool> AutoGeneratedSwitch_O1("O1"
, cl::desc("Optimization level 1"));

cl::opt<bool> AutoGeneratedSwitch_O2("O2"
, cl::desc("Optimization level 2"));

cl::opt<bool> AutoGeneratedSwitch_O3("O3"
, cl::desc("Optimization level 3"));

cl::opt<bool> AutoGeneratedSwitch_c("c"
, cl::desc("Compile and assemble, but do not link"));

cl::list<std::string> AutoGeneratedList_include("include"
, cl::desc("Include the named file prior to preprocessing"));

cl::opt<std::string> AutoGeneratedParameter_linker("linker"
, cl::desc("Choose linker (possible values: gcc, g++)"));

cl::opt<bool> AutoGeneratedSwitch_fPIC("fPIC"
, cl::Hidden, cl::desc("Relocation model: PIC"));

cl::opt<std::string> AutoGeneratedParameter_mtune("mtune"
, cl::Hidden, cl::desc("Target a specific CPU type"));

cl::list<std::string> AutoGeneratedList_l("l"
, cl::Prefix, cl::desc("Search a library when linking"));

cl::list<std::string> AutoGeneratedList_m("m"
, cl::Prefix, cl::Hidden, cl::desc("Enable or disable various extensions (-mmmx, -msse, etc.)"));

cl::list<std::string> AutoGeneratedList_Wl_comma_("Wl,"
, cl::Prefix, cl::desc("Pass options to linker"));

cl::opt<bool> AutoGeneratedSwitch_m32("m32"
, cl::Hidden, cl::desc("Generate code for a 32-bit environment"));

cl::opt<std::string> AutoGeneratedParameter_MF("MF"
, cl::Hidden, cl::desc("Specify a file to write dependencies to"));

cl::list<std::string> AutoGeneratedList_weak_framework("weak_framework"
, cl::Hidden, cl::desc("Specifies a framework to weakly link against"));

cl::opt<bool> AutoGeneratedSwitch_emit_dash_llvm("emit-llvm"
, cl::desc("Emit LLVM .ll files instead of native object files"));

cl::opt<bool> AutoGeneratedSwitch_fsyntax_dash_only("fsyntax-only"
, cl::desc("Stop after checking the input for syntax errors"));

cl::list<std::string> AutoGeneratedSinkOption(cl::Sink);

namespace hooks {
    std::string ConvertToMAttr(const std::vector<std::string>& Arg);
}

namespace {

void PreprocessOptionsLocal() {
    if ((AutoGeneratedSwitch_O3)
         && (AutoGeneratedSwitch_O0 || AutoGeneratedSwitch_O1 || AutoGeneratedSwitch_O2)) {
        AutoGeneratedSwitch_O0 = false;
        AutoGeneratedSwitch_O1 = false;
        AutoGeneratedSwitch_O2 = false;
    }
    if ((AutoGeneratedSwitch_O2)
         && (AutoGeneratedSwitch_O0 || AutoGeneratedSwitch_O1)) {
        AutoGeneratedSwitch_O0 = false;
        AutoGeneratedSwitch_O1 = false;
    }
    if ((AutoGeneratedSwitch_O1)
         && (AutoGeneratedSwitch_O0)) {
        AutoGeneratedSwitch_O0 = false;
    }
}

void PopulateLanguageMapLocal(LanguageMap& langMap) {
    langMap["cc"] = "c++";
    langMap["cp"] = "c++";
    langMap["cxx"] = "c++";
    langMap["cpp"] = "c++";
    langMap["CPP"] = "c++";
    langMap["c++"] = "c++";
    langMap["C"] = "c++";
    langMap["c"] = "c";
    langMap["i"] = "c-cpp-output";
    langMap["mi"] = "objective-c-cpp-output";
    langMap["mm"] = "objective-c++";
    langMap["m"] = "objective-c";
    langMap["s"] = "assembler";
    langMap["S"] = "assembler-with-cpp";
    langMap["ll"] = "llvm-assembler";
    langMap["bc"] = "llvm-bitcode";
    langMap["o"] = "object-code";
    langMap["out"] = "executable";
}

class llc : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llc";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "assembler";
    }

    bool IsJoin() const {
        return false;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        throw std::runtime_error("llc is not a Join tool!");
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "s";
        int out_file_index;

        vec.push_back("-f");
        vec.push_back(inFile.str());
        vec.push_back("-o");
        vec.push_back("");
        out_file_index = vec.size()-1;
        cmd = "llc";
        if (AutoGeneratedSwitch_S) {
            stop_compilation = true;
        }
        if (AutoGeneratedSwitch_O0) {
            vec.push_back("-O0");
        }
        if (AutoGeneratedSwitch_O1) {
            vec.push_back("-O1");
        }
        if (AutoGeneratedSwitch_O2) {
            vec.push_back("-O2");
        }
        if (AutoGeneratedSwitch_O3) {
            vec.push_back("-O3");
        }
        if (AutoGeneratedSwitch_fPIC) {
            vec.push_back("-relocation-model=pic");
        }
        if (AutoGeneratedSwitch_mdynamic_dash_no_dash_pic) {
            vec.push_back("-relocation-model=dynamic-no-pic");
        }
        if (!AutoGeneratedParameter_march.empty()) {
            vec.push_back("-mcpu");
            vec.push_back(AutoGeneratedParameter_mcpu);
        }
        if (!AutoGeneratedParameter_mtune.empty()) {
            vec.push_back("-mcpu");
            vec.push_back(AutoGeneratedParameter_mcpu);
        }
        if (!AutoGeneratedParameter_mcpu.empty()) {
            vec.push_back("-mcpu");
            vec.push_back(AutoGeneratedParameter_mcpu);
        }
        if (!AutoGeneratedList_m.empty()) {
            vec.push_back(hooks::ConvertToMAttr(AutoGeneratedList_m));
        }
        if (!AutoGeneratedList_Wllc_comma_.empty()) {
            std::copy(AutoGeneratedList_Wllc_comma_.begin(), AutoGeneratedList_Wllc_comma_.end(), std::back_inserter(vec));
        }

        std::string out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).str();

        vec[out_file_index] = out_file;
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* llc::InputLanguages_[] = {"llvm-assembler", "llvm-bitcode", 0};

class llvm_as : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_as";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        throw std::runtime_error("llvm_as is not a Join tool!");
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "bc";
        int out_file_index;

        vec.push_back(inFile.str());
        vec.push_back("-o");
        vec.push_back("");
        out_file_index = vec.size()-1;
        cmd = "llvm-as";
        if (AutoGeneratedSwitch_emit_dash_llvm) {
            stop_compilation = true;
        }

        std::string out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).str();

        vec[out_file_index] = out_file;
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* llvm_as::InputLanguages_[] = {"llvm-assembler", 0};

class llvm_gcc_assembler : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_assembler";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "object-code";
    }

    bool IsJoin() const {
        return false;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        throw std::runtime_error("llvm_gcc_assembler is not a Join tool!");
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "o";
        int out_file_index;

        vec.push_back("-c");
        vec.push_back("-x");
        vec.push_back("assembler");
        vec.push_back(inFile.str());
        vec.push_back("-o");
        vec.push_back("");
        out_file_index = vec.size()-1;
        cmd = "llvm-gcc";
        if (AutoGeneratedSwitch_c) {
            stop_compilation = true;
        }
        if (!AutoGeneratedList_Wa_comma_.empty()) {
            std::copy(AutoGeneratedList_Wa_comma_.begin(), AutoGeneratedList_Wa_comma_.end(), std::back_inserter(vec));
        }

        std::string out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).str();

        vec[out_file_index] = out_file;
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* llvm_gcc_assembler::InputLanguages_[] = {"assembler", 0};

class llvm_gcc_c : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_c";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        throw std::runtime_error("llvm_gcc_c is not a Join tool!");
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "bc";
        int out_file_index = -1;

        if (AutoGeneratedSwitch_E) {
            if (!OutputFilename.empty()) {
                vec.push_back("-x");
                vec.push_back("c");
                vec.push_back("-E");
                vec.push_back(inFile.str());
                vec.push_back("-o");
                vec.push_back("");
                out_file_index = vec.size()-1;
                cmd = "llvm-gcc";
            }
            else {
                vec.push_back("-x");
                vec.push_back("c");
                vec.push_back("-E");
                vec.push_back(inFile.str());
                cmd = "llvm-gcc";
            }
        }
        else if (AutoGeneratedSwitch_fsyntax_dash_only) {
            vec.push_back("-x");
            vec.push_back("c");
            vec.push_back("-fsyntax-only");
            vec.push_back(inFile.str());
            cmd = "llvm-gcc";
        }
        else if ((AutoGeneratedSwitch_S)
             && (AutoGeneratedSwitch_emit_dash_llvm)) {
            vec.push_back("-x");
            vec.push_back("c");
            vec.push_back("-S");
            vec.push_back(inFile.str());
            vec.push_back("-o");
            vec.push_back("");
            out_file_index = vec.size()-1;
            vec.push_back("-emit-llvm");
            cmd = "llvm-gcc";
        }
        else {
            vec.push_back("-x");
            vec.push_back("c");
            vec.push_back("-c");
            vec.push_back(inFile.str());
            vec.push_back("-o");
            vec.push_back("");
            out_file_index = vec.size()-1;
            vec.push_back("-emit-llvm");
            cmd = "llvm-gcc";
        }
        if ((InputFilenames.size() > 1)
             && ((AutoGeneratedSwitch_S)
             || (AutoGeneratedSwitch_c))) {
            throw std::runtime_error("cannot specify -o with -c or -S with multiple files");
        }
        if (AutoGeneratedSwitch_E) {
            stop_compilation = true;
            output_suffix = "i";
        }
        if ((AutoGeneratedSwitch_emit_dash_llvm)
             && (AutoGeneratedSwitch_S)) {
            output_suffix = "ll";
            stop_compilation = true;
        }
        if ((AutoGeneratedSwitch_emit_dash_llvm)
             && (AutoGeneratedSwitch_c)) {
            stop_compilation = true;
        }
        if (AutoGeneratedSwitch_fsyntax_dash_only) {
            stop_compilation = true;
        }
        if (!AutoGeneratedList_include.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_include.begin(),
            E = AutoGeneratedList_include.end() ; B != E;) {
                vec.push_back("-include");
                vec.push_back(*B);
                ++B;
            }
        }
        if (!(SaveTemps == SaveTempsEnum::Unset)) {
            vec.push_back("-save-temps");
        }
        if (!AutoGeneratedList_I.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_I.begin(),
            E = AutoGeneratedList_I.end(); B != E;) {
                vec.push_back("-I" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_F.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_F.begin(),
            E = AutoGeneratedList_F.end(); B != E;) {
                vec.push_back("-F" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_D.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_D.begin(),
            E = AutoGeneratedList_D.end(); B != E;) {
                vec.push_back("-D" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedParameter_march.empty()) {
            vec.push_back("-march");
            vec.push_back(AutoGeneratedParameter_march);
        }
        if (!AutoGeneratedParameter_mtune.empty()) {
            vec.push_back("-mtune");
            vec.push_back(AutoGeneratedParameter_mtune);
        }
        if (!AutoGeneratedParameter_mcpu.empty()) {
            vec.push_back("-mcpu");
            vec.push_back(AutoGeneratedParameter_mcpu);
        }
        if (!AutoGeneratedList_m.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_m.begin(),
            E = AutoGeneratedList_m.end(); B != E;) {
                vec.push_back("-m" + *B);
                ++B;
            }
        }
        if (AutoGeneratedSwitch_m32) {
            vec.push_back("-m32");
        }
        if (AutoGeneratedSwitch_m64) {
            vec.push_back("-m64");
        }
        if (AutoGeneratedSwitch_O1) {
            vec.push_back("-O1");
        }
        if (AutoGeneratedSwitch_O2) {
            vec.push_back("-O2");
        }
        if (AutoGeneratedSwitch_O3) {
            vec.push_back("-O3");
        }
        if (AutoGeneratedSwitch_fPIC) {
            vec.push_back("-fPIC");
        }
        if (AutoGeneratedSwitch_mdynamic_dash_no_dash_pic) {
            vec.push_back("-mdynamic-no-pic");
        }
        if (!AutoGeneratedParameter_MF.empty()) {
            vec.push_back("-MF");
            vec.push_back(AutoGeneratedParameter_MF);
        }
        if (!AutoGeneratedParameter_MT.empty()) {
            vec.push_back("-MT");
            vec.push_back(AutoGeneratedParameter_MT);
        }

        std::string out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).str();

        if (out_file_index != -1)
            vec[out_file_index] = out_file;
        if (!AutoGeneratedSinkOption.empty()) {
            vec.insert(vec.end(), AutoGeneratedSinkOption.begin(), AutoGeneratedSinkOption.end());
        }
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* llvm_gcc_c::InputLanguages_[] = {"c", 0};

class llvm_gcc_cpp : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_cpp";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        throw std::runtime_error("llvm_gcc_cpp is not a Join tool!");
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "bc";
        int out_file_index = -1;

        if (AutoGeneratedSwitch_E) {
            if (!OutputFilename.empty()) {
                vec.push_back("-x");
                vec.push_back("c++");
                vec.push_back("-E");
                vec.push_back(inFile.str());
                vec.push_back("-o");
                vec.push_back("");
                out_file_index = vec.size()-1;
                cmd = "llvm-g++";
            }
            else {
                vec.push_back("-x");
                vec.push_back("c++");
                vec.push_back("-E");
                vec.push_back(inFile.str());
                cmd = "llvm-g++";
            }
        }
        else if (AutoGeneratedSwitch_fsyntax_dash_only) {
            vec.push_back("-x");
            vec.push_back("c++");
            vec.push_back("-fsyntax-only");
            vec.push_back(inFile.str());
            cmd = "llvm-g++";
        }
        else if ((AutoGeneratedSwitch_S)
             && (AutoGeneratedSwitch_emit_dash_llvm)) {
            vec.push_back("-x");
            vec.push_back("c++");
            vec.push_back("-S");
            vec.push_back(inFile.str());
            vec.push_back("-o");
            vec.push_back("");
            out_file_index = vec.size()-1;
            vec.push_back("-emit-llvm");
            cmd = "llvm-g++";
        }
        else {
            vec.push_back("-x");
            vec.push_back("c++");
            vec.push_back("-c");
            vec.push_back(inFile.str());
            vec.push_back("-o");
            vec.push_back("");
            out_file_index = vec.size()-1;
            vec.push_back("-emit-llvm");
            cmd = "llvm-g++";
        }
        if ((InputFilenames.size() > 1)
             && ((AutoGeneratedSwitch_S)
             || (AutoGeneratedSwitch_c))) {
            throw std::runtime_error("cannot specify -o with -c or -S with multiple files");
        }
        if (AutoGeneratedSwitch_E) {
            stop_compilation = true;
            output_suffix = "i";
        }
        if ((AutoGeneratedSwitch_emit_dash_llvm)
             && (AutoGeneratedSwitch_S)) {
            output_suffix = "ll";
            stop_compilation = true;
        }
        if ((AutoGeneratedSwitch_emit_dash_llvm)
             && (AutoGeneratedSwitch_c)) {
            stop_compilation = true;
        }
        if (AutoGeneratedSwitch_fsyntax_dash_only) {
            stop_compilation = true;
        }
        if (!AutoGeneratedList_include.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_include.begin(),
            E = AutoGeneratedList_include.end() ; B != E;) {
                vec.push_back("-include");
                vec.push_back(*B);
                ++B;
            }
        }
        if (!(SaveTemps == SaveTempsEnum::Unset)) {
            vec.push_back("-save-temps");
        }
        if (!AutoGeneratedList_I.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_I.begin(),
            E = AutoGeneratedList_I.end(); B != E;) {
                vec.push_back("-I" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_F.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_F.begin(),
            E = AutoGeneratedList_F.end(); B != E;) {
                vec.push_back("-F" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_D.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_D.begin(),
            E = AutoGeneratedList_D.end(); B != E;) {
                vec.push_back("-D" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedParameter_march.empty()) {
            vec.push_back("-march");
            vec.push_back(AutoGeneratedParameter_march);
        }
        if (!AutoGeneratedParameter_mtune.empty()) {
            vec.push_back("-mtune");
            vec.push_back(AutoGeneratedParameter_mtune);
        }
        if (!AutoGeneratedParameter_mcpu.empty()) {
            vec.push_back("-mcpu");
            vec.push_back(AutoGeneratedParameter_mcpu);
        }
        if (!AutoGeneratedList_m.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_m.begin(),
            E = AutoGeneratedList_m.end(); B != E;) {
                vec.push_back("-m" + *B);
                ++B;
            }
        }
        if (AutoGeneratedSwitch_m32) {
            vec.push_back("-m32");
        }
        if (AutoGeneratedSwitch_m64) {
            vec.push_back("-m64");
        }
        if (AutoGeneratedSwitch_O1) {
            vec.push_back("-O1");
        }
        if (AutoGeneratedSwitch_O2) {
            vec.push_back("-O2");
        }
        if (AutoGeneratedSwitch_O3) {
            vec.push_back("-O3");
        }
        if (AutoGeneratedSwitch_fPIC) {
            vec.push_back("-fPIC");
        }
        if (AutoGeneratedSwitch_mdynamic_dash_no_dash_pic) {
            vec.push_back("-mdynamic-no-pic");
        }
        if (!AutoGeneratedParameter_MF.empty()) {
            vec.push_back("-MF");
            vec.push_back(AutoGeneratedParameter_MF);
        }
        if (!AutoGeneratedParameter_MT.empty()) {
            vec.push_back("-MT");
            vec.push_back(AutoGeneratedParameter_MT);
        }

        std::string out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).str();

        if (out_file_index != -1)
            vec[out_file_index] = out_file;
        if (!AutoGeneratedSinkOption.empty()) {
            vec.insert(vec.end(), AutoGeneratedSinkOption.begin(), AutoGeneratedSinkOption.end());
        }
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* llvm_gcc_cpp::InputLanguages_[] = {"c++", 0};

class llvm_gcc_cpp_linker : public JoinTool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_cpp_linker";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "executable";
    }

    bool IsJoin() const {
        return true;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "out";
        int out_file_index;

        for (PathVector::const_iterator B = inFiles.begin(), E = inFiles.end();
        B != E; ++B)
            vec.push_back(B->str());
        vec.push_back("-o");
        vec.push_back("");
        out_file_index = vec.size()-1;
        cmd = "llvm-g++";
        if (AutoGeneratedSwitch_pthread) {
            vec.push_back("-lpthread");
        }
        if (!AutoGeneratedList_L.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_L.begin(),
            E = AutoGeneratedList_L.end(); B != E;) {
                vec.push_back("-L" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_F.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_F.begin(),
            E = AutoGeneratedList_F.end(); B != E;) {
                vec.push_back("-F" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_framework.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_framework.begin(),
            E = AutoGeneratedList_framework.end() ; B != E;) {
                vec.push_back("-framework");
                vec.push_back(*B);
                ++B;
            }
        }
        if (!AutoGeneratedList_weak_framework.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_weak_framework.begin(),
            E = AutoGeneratedList_weak_framework.end() ; B != E;) {
                vec.push_back("-weak_framework");
                vec.push_back(*B);
                ++B;
            }
        }
        if (AutoGeneratedSwitch_m32) {
            vec.push_back("-m32");
        }
        if (AutoGeneratedSwitch_m64) {
            vec.push_back("-m64");
        }
        if (!AutoGeneratedList_l.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_l.begin(),
            E = AutoGeneratedList_l.end(); B != E;) {
                vec.push_back("-l" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_Wl_comma_.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_Wl_comma_.begin(),
            E = AutoGeneratedList_Wl_comma_.end(); B != E;) {
                vec.push_back("-Wl," + *B);
                ++B;
            }
        }

        std::string out_file = OutFilename(sys::Path(),
            TempDir, stop_compilation, output_suffix).str();

        vec[out_file_index] = out_file;
        return Action(cmd, vec, stop_compilation, out_file);
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "out";
        int out_file_index;

        vec.push_back(inFile.str());
        vec.push_back("-o");
        vec.push_back("");
        out_file_index = vec.size()-1;
        cmd = "llvm-g++";
        if (AutoGeneratedSwitch_pthread) {
            vec.push_back("-lpthread");
        }
        if (!AutoGeneratedList_L.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_L.begin(),
            E = AutoGeneratedList_L.end(); B != E;) {
                vec.push_back("-L" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_F.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_F.begin(),
            E = AutoGeneratedList_F.end(); B != E;) {
                vec.push_back("-F" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_framework.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_framework.begin(),
            E = AutoGeneratedList_framework.end() ; B != E;) {
                vec.push_back("-framework");
                vec.push_back(*B);
                ++B;
            }
        }
        if (!AutoGeneratedList_weak_framework.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_weak_framework.begin(),
            E = AutoGeneratedList_weak_framework.end() ; B != E;) {
                vec.push_back("-weak_framework");
                vec.push_back(*B);
                ++B;
            }
        }
        if (AutoGeneratedSwitch_m32) {
            vec.push_back("-m32");
        }
        if (AutoGeneratedSwitch_m64) {
            vec.push_back("-m64");
        }
        if (!AutoGeneratedList_l.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_l.begin(),
            E = AutoGeneratedList_l.end(); B != E;) {
                vec.push_back("-l" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_Wl_comma_.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_Wl_comma_.begin(),
            E = AutoGeneratedList_Wl_comma_.end(); B != E;) {
                vec.push_back("-Wl," + *B);
                ++B;
            }
        }

        std::string out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).str();

        vec[out_file_index] = out_file;
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* llvm_gcc_cpp_linker::InputLanguages_[] = {"object-code", 0};

class llvm_gcc_linker : public JoinTool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_linker";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "executable";
    }

    bool IsJoin() const {
        return true;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "out";
        int out_file_index;

        for (PathVector::const_iterator B = inFiles.begin(), E = inFiles.end();
        B != E; ++B)
            vec.push_back(B->str());
        vec.push_back("-o");
        vec.push_back("");
        out_file_index = vec.size()-1;
        cmd = "llvm-gcc";
        if (AutoGeneratedSwitch_pthread) {
            vec.push_back("-lpthread");
        }
        if (!AutoGeneratedList_L.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_L.begin(),
            E = AutoGeneratedList_L.end(); B != E;) {
                vec.push_back("-L" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_F.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_F.begin(),
            E = AutoGeneratedList_F.end(); B != E;) {
                vec.push_back("-F" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_framework.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_framework.begin(),
            E = AutoGeneratedList_framework.end() ; B != E;) {
                vec.push_back("-framework");
                vec.push_back(*B);
                ++B;
            }
        }
        if (!AutoGeneratedList_weak_framework.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_weak_framework.begin(),
            E = AutoGeneratedList_weak_framework.end() ; B != E;) {
                vec.push_back("-weak_framework");
                vec.push_back(*B);
                ++B;
            }
        }
        if (AutoGeneratedSwitch_m32) {
            vec.push_back("-m32");
        }
        if (AutoGeneratedSwitch_m64) {
            vec.push_back("-m64");
        }
        if (!AutoGeneratedList_l.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_l.begin(),
            E = AutoGeneratedList_l.end(); B != E;) {
                vec.push_back("-l" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_Wl_comma_.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_Wl_comma_.begin(),
            E = AutoGeneratedList_Wl_comma_.end(); B != E;) {
                vec.push_back("-Wl," + *B);
                ++B;
            }
        }

        std::string out_file = OutFilename(sys::Path(),
            TempDir, stop_compilation, output_suffix).str();

        vec[out_file_index] = out_file;
        return Action(cmd, vec, stop_compilation, out_file);
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "out";
        int out_file_index;

        vec.push_back(inFile.str());
        vec.push_back("-o");
        vec.push_back("");
        out_file_index = vec.size()-1;
        cmd = "llvm-gcc";
        if (AutoGeneratedSwitch_pthread) {
            vec.push_back("-lpthread");
        }
        if (!AutoGeneratedList_L.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_L.begin(),
            E = AutoGeneratedList_L.end(); B != E;) {
                vec.push_back("-L" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_F.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_F.begin(),
            E = AutoGeneratedList_F.end(); B != E;) {
                vec.push_back("-F" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_framework.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_framework.begin(),
            E = AutoGeneratedList_framework.end() ; B != E;) {
                vec.push_back("-framework");
                vec.push_back(*B);
                ++B;
            }
        }
        if (!AutoGeneratedList_weak_framework.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_weak_framework.begin(),
            E = AutoGeneratedList_weak_framework.end() ; B != E;) {
                vec.push_back("-weak_framework");
                vec.push_back(*B);
                ++B;
            }
        }
        if (AutoGeneratedSwitch_m32) {
            vec.push_back("-m32");
        }
        if (AutoGeneratedSwitch_m64) {
            vec.push_back("-m64");
        }
        if (!AutoGeneratedList_l.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_l.begin(),
            E = AutoGeneratedList_l.end(); B != E;) {
                vec.push_back("-l" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_Wl_comma_.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_Wl_comma_.begin(),
            E = AutoGeneratedList_Wl_comma_.end(); B != E;) {
                vec.push_back("-Wl," + *B);
                ++B;
            }
        }

        std::string out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).str();

        vec[out_file_index] = out_file;
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* llvm_gcc_linker::InputLanguages_[] = {"object-code", 0};

class llvm_gcc_m : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_m";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        throw std::runtime_error("llvm_gcc_m is not a Join tool!");
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "bc";
        int out_file_index = -1;

        if (AutoGeneratedSwitch_E) {
            if (!OutputFilename.empty()) {
                vec.push_back("-x");
                vec.push_back("objective-c");
                vec.push_back("-E");
                vec.push_back(inFile.str());
                vec.push_back("-o");
                vec.push_back("");
                out_file_index = vec.size()-1;
                cmd = "llvm-gcc";
            }
            else {
                vec.push_back("-x");
                vec.push_back("objective-c");
                vec.push_back("-E");
                vec.push_back(inFile.str());
                cmd = "llvm-gcc";
            }
        }
        else if (AutoGeneratedSwitch_fsyntax_dash_only) {
            vec.push_back("-x");
            vec.push_back("objective-c");
            vec.push_back("-fsyntax-only");
            vec.push_back(inFile.str());
            cmd = "llvm-gcc";
        }
        else if ((AutoGeneratedSwitch_S)
             && (AutoGeneratedSwitch_emit_dash_llvm)) {
            vec.push_back("-x");
            vec.push_back("objective-c");
            vec.push_back("-S");
            vec.push_back(inFile.str());
            vec.push_back("-o");
            vec.push_back("");
            out_file_index = vec.size()-1;
            vec.push_back("-emit-llvm");
            cmd = "llvm-gcc";
        }
        else {
            vec.push_back("-x");
            vec.push_back("objective-c");
            vec.push_back("-c");
            vec.push_back(inFile.str());
            vec.push_back("-o");
            vec.push_back("");
            out_file_index = vec.size()-1;
            vec.push_back("-emit-llvm");
            cmd = "llvm-gcc";
        }
        if ((InputFilenames.size() > 1)
             && ((AutoGeneratedSwitch_S)
             || (AutoGeneratedSwitch_c))) {
            throw std::runtime_error("cannot specify -o with -c or -S with multiple files");
        }
        if (AutoGeneratedSwitch_E) {
            stop_compilation = true;
            output_suffix = "mi";
        }
        if ((AutoGeneratedSwitch_emit_dash_llvm)
             && (AutoGeneratedSwitch_S)) {
            output_suffix = "ll";
            stop_compilation = true;
        }
        if ((AutoGeneratedSwitch_emit_dash_llvm)
             && (AutoGeneratedSwitch_c)) {
            stop_compilation = true;
        }
        if (AutoGeneratedSwitch_fsyntax_dash_only) {
            stop_compilation = true;
        }
        if (!AutoGeneratedList_include.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_include.begin(),
            E = AutoGeneratedList_include.end() ; B != E;) {
                vec.push_back("-include");
                vec.push_back(*B);
                ++B;
            }
        }
        if (!(SaveTemps == SaveTempsEnum::Unset)) {
            vec.push_back("-save-temps");
        }
        if (!AutoGeneratedList_I.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_I.begin(),
            E = AutoGeneratedList_I.end(); B != E;) {
                vec.push_back("-I" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_F.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_F.begin(),
            E = AutoGeneratedList_F.end(); B != E;) {
                vec.push_back("-F" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_D.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_D.begin(),
            E = AutoGeneratedList_D.end(); B != E;) {
                vec.push_back("-D" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedParameter_march.empty()) {
            vec.push_back("-march");
            vec.push_back(AutoGeneratedParameter_march);
        }
        if (!AutoGeneratedParameter_mtune.empty()) {
            vec.push_back("-mtune");
            vec.push_back(AutoGeneratedParameter_mtune);
        }
        if (!AutoGeneratedParameter_mcpu.empty()) {
            vec.push_back("-mcpu");
            vec.push_back(AutoGeneratedParameter_mcpu);
        }
        if (!AutoGeneratedList_m.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_m.begin(),
            E = AutoGeneratedList_m.end(); B != E;) {
                vec.push_back("-m" + *B);
                ++B;
            }
        }
        if (AutoGeneratedSwitch_m32) {
            vec.push_back("-m32");
        }
        if (AutoGeneratedSwitch_m64) {
            vec.push_back("-m64");
        }
        if (AutoGeneratedSwitch_O1) {
            vec.push_back("-O1");
        }
        if (AutoGeneratedSwitch_O2) {
            vec.push_back("-O2");
        }
        if (AutoGeneratedSwitch_O3) {
            vec.push_back("-O3");
        }
        if (AutoGeneratedSwitch_fPIC) {
            vec.push_back("-fPIC");
        }
        if (AutoGeneratedSwitch_mdynamic_dash_no_dash_pic) {
            vec.push_back("-mdynamic-no-pic");
        }
        if (!AutoGeneratedParameter_MF.empty()) {
            vec.push_back("-MF");
            vec.push_back(AutoGeneratedParameter_MF);
        }
        if (!AutoGeneratedParameter_MT.empty()) {
            vec.push_back("-MT");
            vec.push_back(AutoGeneratedParameter_MT);
        }

        std::string out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).str();

        if (out_file_index != -1)
            vec[out_file_index] = out_file;
        if (!AutoGeneratedSinkOption.empty()) {
            vec.insert(vec.end(), AutoGeneratedSinkOption.begin(), AutoGeneratedSinkOption.end());
        }
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* llvm_gcc_m::InputLanguages_[] = {"objective-c", 0};

class llvm_gcc_mxx : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_mxx";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        throw std::runtime_error("llvm_gcc_mxx is not a Join tool!");
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "bc";
        int out_file_index = -1;

        if (AutoGeneratedSwitch_E) {
            if (!OutputFilename.empty()) {
                vec.push_back("-x");
                vec.push_back("objective-c++");
                vec.push_back("-E");
                vec.push_back(inFile.str());
                vec.push_back("-o");
                vec.push_back("");
                out_file_index = vec.size()-1;
                cmd = "llvm-gcc";
            }
            else {
                vec.push_back("-x");
                vec.push_back("objective-c++");
                vec.push_back("-E");
                vec.push_back(inFile.str());
                cmd = "llvm-gcc";
            }
        }
        else if (AutoGeneratedSwitch_fsyntax_dash_only) {
            vec.push_back("-x");
            vec.push_back("objective-c++");
            vec.push_back("-fsyntax-only");
            vec.push_back(inFile.str());
            cmd = "llvm-gcc";
        }
        else if ((AutoGeneratedSwitch_S)
             && (AutoGeneratedSwitch_emit_dash_llvm)) {
            vec.push_back("-x");
            vec.push_back("objective-c++");
            vec.push_back("-S");
            vec.push_back(inFile.str());
            vec.push_back("-o");
            vec.push_back("");
            out_file_index = vec.size()-1;
            vec.push_back("-emit-llvm");
            cmd = "llvm-gcc";
        }
        else {
            vec.push_back("-x");
            vec.push_back("objective-c++");
            vec.push_back("-c");
            vec.push_back(inFile.str());
            vec.push_back("-o");
            vec.push_back("");
            out_file_index = vec.size()-1;
            vec.push_back("-emit-llvm");
            cmd = "llvm-gcc";
        }
        if ((InputFilenames.size() > 1)
             && ((AutoGeneratedSwitch_S)
             || (AutoGeneratedSwitch_c))) {
            throw std::runtime_error("cannot specify -o with -c or -S with multiple files");
        }
        if (AutoGeneratedSwitch_E) {
            stop_compilation = true;
            output_suffix = "mi";
        }
        if ((AutoGeneratedSwitch_emit_dash_llvm)
             && (AutoGeneratedSwitch_S)) {
            output_suffix = "ll";
            stop_compilation = true;
        }
        if ((AutoGeneratedSwitch_emit_dash_llvm)
             && (AutoGeneratedSwitch_c)) {
            stop_compilation = true;
        }
        if (AutoGeneratedSwitch_fsyntax_dash_only) {
            stop_compilation = true;
        }
        if (!AutoGeneratedList_include.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_include.begin(),
            E = AutoGeneratedList_include.end() ; B != E;) {
                vec.push_back("-include");
                vec.push_back(*B);
                ++B;
            }
        }
        if (!(SaveTemps == SaveTempsEnum::Unset)) {
            vec.push_back("-save-temps");
        }
        if (!AutoGeneratedList_I.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_I.begin(),
            E = AutoGeneratedList_I.end(); B != E;) {
                vec.push_back("-I" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_F.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_F.begin(),
            E = AutoGeneratedList_F.end(); B != E;) {
                vec.push_back("-F" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedList_D.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_D.begin(),
            E = AutoGeneratedList_D.end(); B != E;) {
                vec.push_back("-D" + *B);
                ++B;
            }
        }
        if (!AutoGeneratedParameter_march.empty()) {
            vec.push_back("-march");
            vec.push_back(AutoGeneratedParameter_march);
        }
        if (!AutoGeneratedParameter_mtune.empty()) {
            vec.push_back("-mtune");
            vec.push_back(AutoGeneratedParameter_mtune);
        }
        if (!AutoGeneratedParameter_mcpu.empty()) {
            vec.push_back("-mcpu");
            vec.push_back(AutoGeneratedParameter_mcpu);
        }
        if (!AutoGeneratedList_m.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_m.begin(),
            E = AutoGeneratedList_m.end(); B != E;) {
                vec.push_back("-m" + *B);
                ++B;
            }
        }
        if (AutoGeneratedSwitch_m32) {
            vec.push_back("-m32");
        }
        if (AutoGeneratedSwitch_m64) {
            vec.push_back("-m64");
        }
        if (AutoGeneratedSwitch_O1) {
            vec.push_back("-O1");
        }
        if (AutoGeneratedSwitch_O2) {
            vec.push_back("-O2");
        }
        if (AutoGeneratedSwitch_O3) {
            vec.push_back("-O3");
        }
        if (AutoGeneratedSwitch_fPIC) {
            vec.push_back("-fPIC");
        }
        if (AutoGeneratedSwitch_mdynamic_dash_no_dash_pic) {
            vec.push_back("-mdynamic-no-pic");
        }
        if (!AutoGeneratedParameter_MF.empty()) {
            vec.push_back("-MF");
            vec.push_back(AutoGeneratedParameter_MF);
        }
        if (!AutoGeneratedParameter_MT.empty()) {
            vec.push_back("-MT");
            vec.push_back(AutoGeneratedParameter_MT);
        }

        std::string out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).str();

        if (out_file_index != -1)
            vec[out_file_index] = out_file;
        if (!AutoGeneratedSinkOption.empty()) {
            vec.insert(vec.end(), AutoGeneratedSinkOption.begin(), AutoGeneratedSinkOption.end());
        }
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* llvm_gcc_mxx::InputLanguages_[] = {"objective-c++", 0};

class opt : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "opt";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        throw std::runtime_error("opt is not a Join tool!");
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "bc";
        int out_file_index;

        vec.push_back("-f");
        vec.push_back(inFile.str());
        vec.push_back("-o");
        vec.push_back("");
        out_file_index = vec.size()-1;
        cmd = "opt";
        if (!AutoGeneratedList_Wo_comma_.empty()) {
            std::copy(AutoGeneratedList_Wo_comma_.begin(), AutoGeneratedList_Wo_comma_.end(), std::back_inserter(vec));
        }
        if (AutoGeneratedSwitch_O1) {
            vec.push_back("-O1");
        }
        if (AutoGeneratedSwitch_O2) {
            vec.push_back("-O2");
        }
        if (AutoGeneratedSwitch_O3) {
            vec.push_back("-O3");
        }

        std::string out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).str();

        vec[out_file_index] = out_file;
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* opt::InputLanguages_[] = {"llvm-bitcode", 0};

class Edge11: public Edge {
public:
    Edge11() : Edge("llvm_as") {}

    unsigned Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (AutoGeneratedSwitch_emit_dash_llvm) {
            ret += 2;
        }
        return ret;
    };

};

class Edge12: public Edge {
public:
    Edge12() : Edge("opt") {}

    unsigned Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (AutoGeneratedSwitch_opt) {
            ret += 2;
        }
        return ret;
    };

};

class Edge13: public Edge {
public:
    Edge13() : Edge("opt") {}

    unsigned Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (AutoGeneratedSwitch_opt) {
            ret += 2;
        }
        return ret;
    };

};

class Edge14: public Edge {
public:
    Edge14() : Edge("opt") {}

    unsigned Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (AutoGeneratedSwitch_opt) {
            ret += 2;
        }
        return ret;
    };

};

class Edge15: public Edge {
public:
    Edge15() : Edge("opt") {}

    unsigned Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (AutoGeneratedSwitch_opt) {
            ret += 2;
        }
        return ret;
    };

};

class Edge16: public Edge {
public:
    Edge16() : Edge("opt") {}

    unsigned Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (AutoGeneratedSwitch_opt) {
            ret += 2;
        }
        return ret;
    };

};

class Edge20: public Edge {
public:
    Edge20() : Edge("llvm_gcc_cpp_linker") {}

    unsigned Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if ((InLangs.count("c++") != 0)
             || (InLangs.count("objective-c++") != 0)) {
            ret += 2;
        }
        if ((AutoGeneratedParameter_linker == "g++")
             || (AutoGeneratedParameter_linker == "c++")) {
            ret += 2;
        }
        return ret;
    };

};

class Edge22: public Edge {
public:
    Edge22() : Edge("llvm_gcc_cpp_linker") {}

    unsigned Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if ((InLangs.count("c++") != 0)
             || (InLangs.count("objective-c++") != 0)) {
            ret += 2;
        }
        if ((AutoGeneratedParameter_linker == "g++")
             || (AutoGeneratedParameter_linker == "c++")) {
            ret += 2;
        }
        return ret;
    };

};

void PopulateCompilationGraphLocal(CompilationGraph& G) {
    G.insertNode(new llc());
    G.insertNode(new llvm_as());
    G.insertNode(new llvm_gcc_assembler());
    G.insertNode(new llvm_gcc_c());
    G.insertNode(new llvm_gcc_cpp());
    G.insertNode(new llvm_gcc_cpp_linker());
    G.insertNode(new llvm_gcc_linker());
    G.insertNode(new llvm_gcc_m());
    G.insertNode(new llvm_gcc_mxx());
    G.insertNode(new opt());

    G.insertEdge("root", new SimpleEdge("llvm_gcc_c"));
    G.insertEdge("root", new SimpleEdge("llvm_gcc_assembler"));
    G.insertEdge("root", new SimpleEdge("llvm_gcc_cpp"));
    G.insertEdge("root", new SimpleEdge("llvm_gcc_m"));
    G.insertEdge("root", new SimpleEdge("llvm_gcc_mxx"));
    G.insertEdge("root", new SimpleEdge("llc"));
    G.insertEdge("llvm_gcc_c", new SimpleEdge("llc"));
    G.insertEdge("llvm_gcc_cpp", new SimpleEdge("llc"));
    G.insertEdge("llvm_gcc_m", new SimpleEdge("llc"));
    G.insertEdge("llvm_gcc_mxx", new SimpleEdge("llc"));
    G.insertEdge("llvm_as", new SimpleEdge("llc"));
    G.insertEdge("root", new Edge11());
    G.insertEdge("llvm_gcc_c", new Edge12());
    G.insertEdge("llvm_gcc_cpp", new Edge13());
    G.insertEdge("llvm_gcc_m", new Edge14());
    G.insertEdge("llvm_gcc_mxx", new Edge15());
    G.insertEdge("llvm_as", new Edge16());
    G.insertEdge("opt", new SimpleEdge("llc"));
    G.insertEdge("llc", new SimpleEdge("llvm_gcc_assembler"));
    G.insertEdge("llvm_gcc_assembler", new SimpleEdge("llvm_gcc_linker"));
    G.insertEdge("llvm_gcc_assembler", new Edge20());
    G.insertEdge("root", new SimpleEdge("llvm_gcc_linker"));
    G.insertEdge("root", new Edge22());
}

struct Plugin : public llvmc::BasePlugin {

    int Priority() const { return 0; }

    void PreprocessOptions() const
    { PreprocessOptionsLocal(); }

    void PopulateLanguageMap(LanguageMap& langMap) const
    { PopulateLanguageMapLocal(langMap); }

    void PopulateCompilationGraph(CompilationGraph& graph) const
    { PopulateCompilationGraphLocal(graph); }
};

static llvmc::RegisterPlugin<Plugin> RP;

} // End anonymous namespace.

namespace llvmc {
LLVMC_FORCE_LINKAGE_DECL(LLVMC_PLUGIN_NAME) {}
}
