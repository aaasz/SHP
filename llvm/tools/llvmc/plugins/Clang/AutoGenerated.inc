//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// LLVMC Configuration Library
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

#include "llvm/CompilerDriver/BuiltinOptions.h"
#include "llvm/CompilerDriver/CompilationGraph.h"
#include "llvm/CompilerDriver/ForceLinkageMacros.h"
#include "llvm/CompilerDriver/Plugin.h"
#include "llvm/CompilerDriver/Tool.h"

#include "llvm/Support/CommandLine.h"
#include "llvm/Support/raw_ostream.h"

#include <algorithm>
#include <cstdlib>
#include <iterator>
#include <stdexcept>

using namespace llvm;
using namespace llvmc;

extern cl::opt<std::string> OutputFilename;

inline const char* checkCString(const char* s)
{ return s == NULL ? "" : s; }

extern cl::opt<bool> AutoGeneratedSwitch_c;
extern cl::list<std::string> AutoGeneratedList_include;
extern cl::opt<bool> AutoGeneratedSwitch_E;
cl::opt<bool> AutoGeneratedSwitch_clang("clang"
, cl::desc("Use Clang instead of llvm-gcc"));

extern cl::list<std::string> AutoGeneratedList_Wa_comma_;
extern cl::opt<bool> AutoGeneratedSwitch_pthread;
extern cl::list<std::string> AutoGeneratedList_I;
extern cl::list<std::string> AutoGeneratedList_L;
extern cl::list<std::string> AutoGeneratedList_l;
extern cl::list<std::string> AutoGeneratedList_Wl_comma_;
extern cl::opt<bool> AutoGeneratedSwitch_S;
extern cl::opt<bool> AutoGeneratedSwitch_emit_dash_llvm;
extern cl::opt<bool> AutoGeneratedSwitch_fsyntax_dash_only;
extern cl::list<std::string> AutoGeneratedSinkOption;

namespace {

void PreprocessOptionsLocal() {
}

void PopulateLanguageMapLocal(LanguageMap& langMap) {
    langMap["cc"] = "c++";
    langMap["cp"] = "c++";
    langMap["cxx"] = "c++";
    langMap["cpp"] = "c++";
    langMap["CPP"] = "c++";
    langMap["c++"] = "c++";
    langMap["C"] = "c++";
    langMap["c"] = "c";
    langMap["m"] = "objective-c";
    langMap["i"] = "c-cpp-output";
    langMap["mi"] = "objective-c-cpp-output";
}

class as : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "as";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "object-code";
    }

    bool IsJoin() const {
        return false;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        throw std::runtime_error("as is not a Join tool!");
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "o";
        int out_file_index;

        vec.push_back(inFile.str());
        vec.push_back("-o");
        vec.push_back("");
        out_file_index = vec.size()-1;
        cmd = "as";
        if (!AutoGeneratedList_Wa_comma_.empty()) {
            std::copy(AutoGeneratedList_Wa_comma_.begin(), AutoGeneratedList_Wa_comma_.end(), std::back_inserter(vec));
        }
        if (AutoGeneratedSwitch_c) {
            stop_compilation = true;
        }

        std::string out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).str();

        vec[out_file_index] = out_file;
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* as::InputLanguages_[] = {"assembler", 0};

class clang_c : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "clang_c";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        throw std::runtime_error("clang_c is not a Join tool!");
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "bc";
        int out_file_index = -1;

        if (AutoGeneratedSwitch_E) {
            if (!OutputFilename.empty()) {
                vec.push_back("-x");
                vec.push_back("c");
                vec.push_back("-E");
                vec.push_back(inFile.str());
                vec.push_back("-o");
                vec.push_back("");
                out_file_index = vec.size()-1;
                cmd = "clang";
            }
            else {
                vec.push_back("-x");
                vec.push_back("c");
                vec.push_back("-E");
                vec.push_back(inFile.str());
                cmd = "clang";
            }
        }
        else if ((AutoGeneratedSwitch_S)
             && (AutoGeneratedSwitch_emit_dash_llvm)) {
            vec.push_back("-x");
            vec.push_back("c");
            vec.push_back("-emit-llvm");
            vec.push_back(inFile.str());
            vec.push_back("-o");
            vec.push_back("");
            out_file_index = vec.size()-1;
            cmd = "clang";
        }
        else {
            vec.push_back("-x");
            vec.push_back("c");
            vec.push_back("-emit-llvm-bc");
            vec.push_back(inFile.str());
            vec.push_back("-o");
            vec.push_back("");
            out_file_index = vec.size()-1;
            cmd = "clang";
        }
        if (AutoGeneratedSwitch_E) {
            stop_compilation = true;
            output_suffix = "i";
        }
        if (AutoGeneratedSwitch_fsyntax_dash_only) {
            stop_compilation = true;
        }
        if ((AutoGeneratedSwitch_S)
             && (AutoGeneratedSwitch_emit_dash_llvm)) {
            stop_compilation = true;
            output_suffix = "ll";
        }
        if ((AutoGeneratedSwitch_c)
             && (AutoGeneratedSwitch_emit_dash_llvm)) {
            stop_compilation = true;
        }
        if (!AutoGeneratedList_include.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_include.begin(),
            E = AutoGeneratedList_include.end() ; B != E;) {
                vec.push_back("-include");
                vec.push_back(*B);
                ++B;
            }
        }
        if (!AutoGeneratedList_I.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_I.begin(),
            E = AutoGeneratedList_I.end() ; B != E;) {
                vec.push_back("-I");
                vec.push_back(*B);
                ++B;
            }
        }

        std::string out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).str();

        if (out_file_index != -1)
            vec[out_file_index] = out_file;
        if (!AutoGeneratedSinkOption.empty()) {
            vec.insert(vec.end(), AutoGeneratedSinkOption.begin(), AutoGeneratedSinkOption.end());
        }
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* clang_c::InputLanguages_[] = {"c", 0};

class clang_cpp : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "clang_cpp";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        throw std::runtime_error("clang_cpp is not a Join tool!");
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "bc";
        int out_file_index = -1;

        if (AutoGeneratedSwitch_E) {
            if (!OutputFilename.empty()) {
                vec.push_back("-x");
                vec.push_back("c++");
                vec.push_back("-E");
                vec.push_back(inFile.str());
                vec.push_back("-o");
                vec.push_back("");
                out_file_index = vec.size()-1;
                cmd = "clang";
            }
            else {
                vec.push_back("-x");
                vec.push_back("c++");
                vec.push_back("-E");
                vec.push_back(inFile.str());
                cmd = "clang";
            }
        }
        else if ((AutoGeneratedSwitch_S)
             && (AutoGeneratedSwitch_emit_dash_llvm)) {
            vec.push_back("-x");
            vec.push_back("c++");
            vec.push_back("-emit-llvm");
            vec.push_back(inFile.str());
            vec.push_back("-o");
            vec.push_back("");
            out_file_index = vec.size()-1;
            cmd = "clang";
        }
        else {
            vec.push_back("-x");
            vec.push_back("c++");
            vec.push_back("-emit-llvm-bc");
            vec.push_back(inFile.str());
            vec.push_back("-o");
            vec.push_back("");
            out_file_index = vec.size()-1;
            cmd = "clang";
        }
        if (AutoGeneratedSwitch_E) {
            stop_compilation = true;
            output_suffix = "i";
        }
        if (AutoGeneratedSwitch_fsyntax_dash_only) {
            stop_compilation = true;
        }
        if ((AutoGeneratedSwitch_S)
             && (AutoGeneratedSwitch_emit_dash_llvm)) {
            stop_compilation = true;
            output_suffix = "ll";
        }
        if ((AutoGeneratedSwitch_c)
             && (AutoGeneratedSwitch_emit_dash_llvm)) {
            stop_compilation = true;
        }
        if (!AutoGeneratedList_include.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_include.begin(),
            E = AutoGeneratedList_include.end() ; B != E;) {
                vec.push_back("-include");
                vec.push_back(*B);
                ++B;
            }
        }
        if (!AutoGeneratedList_I.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_I.begin(),
            E = AutoGeneratedList_I.end() ; B != E;) {
                vec.push_back("-I");
                vec.push_back(*B);
                ++B;
            }
        }

        std::string out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).str();

        if (out_file_index != -1)
            vec[out_file_index] = out_file;
        if (!AutoGeneratedSinkOption.empty()) {
            vec.insert(vec.end(), AutoGeneratedSinkOption.begin(), AutoGeneratedSinkOption.end());
        }
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* clang_cpp::InputLanguages_[] = {"c++", 0};

class clang_objective_c : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "clang_objective_c";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        throw std::runtime_error("clang_objective_c is not a Join tool!");
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "bc";
        int out_file_index = -1;

        if (AutoGeneratedSwitch_E) {
            if (!OutputFilename.empty()) {
                vec.push_back("-x");
                vec.push_back("objective-c");
                vec.push_back("-E");
                vec.push_back(inFile.str());
                vec.push_back("-o");
                vec.push_back("");
                out_file_index = vec.size()-1;
                cmd = "clang";
            }
            else {
                vec.push_back("-x");
                vec.push_back("objective-c");
                vec.push_back("-E");
                vec.push_back(inFile.str());
                cmd = "clang";
            }
        }
        else if ((AutoGeneratedSwitch_S)
             && (AutoGeneratedSwitch_emit_dash_llvm)) {
            vec.push_back("-x");
            vec.push_back("objective-c");
            vec.push_back("-emit-llvm");
            vec.push_back(inFile.str());
            vec.push_back("-o");
            vec.push_back("");
            out_file_index = vec.size()-1;
            cmd = "clang";
        }
        else {
            vec.push_back("-x");
            vec.push_back("objective-c");
            vec.push_back("-emit-llvm-bc");
            vec.push_back(inFile.str());
            vec.push_back("-o");
            vec.push_back("");
            out_file_index = vec.size()-1;
            cmd = "clang";
        }
        if (AutoGeneratedSwitch_E) {
            stop_compilation = true;
            output_suffix = "mi";
        }
        if (AutoGeneratedSwitch_fsyntax_dash_only) {
            stop_compilation = true;
        }
        if ((AutoGeneratedSwitch_S)
             && (AutoGeneratedSwitch_emit_dash_llvm)) {
            stop_compilation = true;
            output_suffix = "ll";
        }
        if ((AutoGeneratedSwitch_c)
             && (AutoGeneratedSwitch_emit_dash_llvm)) {
            stop_compilation = true;
        }
        if (!AutoGeneratedList_include.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_include.begin(),
            E = AutoGeneratedList_include.end() ; B != E;) {
                vec.push_back("-include");
                vec.push_back(*B);
                ++B;
            }
        }
        if (!AutoGeneratedList_I.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_I.begin(),
            E = AutoGeneratedList_I.end() ; B != E;) {
                vec.push_back("-I");
                vec.push_back(*B);
                ++B;
            }
        }

        std::string out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).str();

        if (out_file_index != -1)
            vec[out_file_index] = out_file;
        if (!AutoGeneratedSinkOption.empty()) {
            vec.insert(vec.end(), AutoGeneratedSinkOption.begin(), AutoGeneratedSinkOption.end());
        }
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* clang_objective_c::InputLanguages_[] = {"objective-c", 0};

class clang_objective_cpp : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "clang_objective_cpp";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        throw std::runtime_error("clang_objective_cpp is not a Join tool!");
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "bc";
        int out_file_index = -1;

        if (AutoGeneratedSwitch_E) {
            if (!OutputFilename.empty()) {
                vec.push_back("-x");
                vec.push_back("objective-c++");
                vec.push_back("-E");
                vec.push_back(inFile.str());
                vec.push_back("-o");
                vec.push_back("");
                out_file_index = vec.size()-1;
                cmd = "clang";
            }
            else {
                vec.push_back("-x");
                vec.push_back("objective-c++");
                vec.push_back("-E");
                vec.push_back(inFile.str());
                cmd = "clang";
            }
        }
        else if ((AutoGeneratedSwitch_S)
             && (AutoGeneratedSwitch_emit_dash_llvm)) {
            vec.push_back("-x");
            vec.push_back("objective-c++");
            vec.push_back("-emit-llvm");
            vec.push_back(inFile.str());
            vec.push_back("-o");
            vec.push_back("");
            out_file_index = vec.size()-1;
            cmd = "clang";
        }
        else {
            vec.push_back("-x");
            vec.push_back("objective-c++");
            vec.push_back("-emit-llvm-bc");
            vec.push_back(inFile.str());
            vec.push_back("-o");
            vec.push_back("");
            out_file_index = vec.size()-1;
            cmd = "clang";
        }
        if (AutoGeneratedSwitch_E) {
            stop_compilation = true;
            output_suffix = "mi";
        }
        if (AutoGeneratedSwitch_fsyntax_dash_only) {
            stop_compilation = true;
        }
        if ((AutoGeneratedSwitch_S)
             && (AutoGeneratedSwitch_emit_dash_llvm)) {
            stop_compilation = true;
            output_suffix = "ll";
        }
        if ((AutoGeneratedSwitch_c)
             && (AutoGeneratedSwitch_emit_dash_llvm)) {
            stop_compilation = true;
        }
        if (!AutoGeneratedList_include.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_include.begin(),
            E = AutoGeneratedList_include.end() ; B != E;) {
                vec.push_back("-include");
                vec.push_back(*B);
                ++B;
            }
        }
        if (!AutoGeneratedList_I.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_I.begin(),
            E = AutoGeneratedList_I.end() ; B != E;) {
                vec.push_back("-I");
                vec.push_back(*B);
                ++B;
            }
        }

        std::string out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).str();

        if (out_file_index != -1)
            vec[out_file_index] = out_file;
        if (!AutoGeneratedSinkOption.empty()) {
            vec.insert(vec.end(), AutoGeneratedSinkOption.begin(), AutoGeneratedSinkOption.end());
        }
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* clang_objective_cpp::InputLanguages_[] = {"objective-c++", 0};

class llvm_ld : public JoinTool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_ld";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "executable";
    }

    bool IsJoin() const {
        return true;
    }

    Action GenerateAction(const PathVector& inFiles,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "out";
        int out_file_index;

        vec.push_back("-native");
        vec.push_back("-disable-internalize");
        for (PathVector::const_iterator B = inFiles.begin(), E = inFiles.end();
        B != E; ++B)
            vec.push_back(B->str());
        vec.push_back("-o");
        vec.push_back("");
        out_file_index = vec.size()-1;
        cmd = "llvm-ld";
        if (AutoGeneratedSwitch_pthread) {
            vec.push_back("-lpthread");
        }
        if (!AutoGeneratedList_L.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_L.begin(),
            E = AutoGeneratedList_L.end() ; B != E;) {
                vec.push_back("-L");
                vec.push_back(*B);
                ++B;
            }
        }
        if (!AutoGeneratedList_l.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_l.begin(),
            E = AutoGeneratedList_l.end() ; B != E;) {
                vec.push_back("-l");
                vec.push_back(*B);
                ++B;
            }
        }
        if (!AutoGeneratedList_Wl_comma_.empty()) {
            std::copy(AutoGeneratedList_Wl_comma_.begin(), AutoGeneratedList_Wl_comma_.end(), std::back_inserter(vec));
        }

        std::string out_file = OutFilename(sys::Path(),
            TempDir, stop_compilation, output_suffix).str();

        vec[out_file_index] = out_file;
        return Action(cmd, vec, stop_compilation, out_file);
    }

    Action GenerateAction(const sys::Path& inFile,
        bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::vector<std::string> vec;
        bool stop_compilation = !HasChildren;
        const char* output_suffix = "out";
        int out_file_index;

        vec.push_back("-native");
        vec.push_back("-disable-internalize");
        vec.push_back(inFile.str());
        vec.push_back("-o");
        vec.push_back("");
        out_file_index = vec.size()-1;
        cmd = "llvm-ld";
        if (AutoGeneratedSwitch_pthread) {
            vec.push_back("-lpthread");
        }
        if (!AutoGeneratedList_L.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_L.begin(),
            E = AutoGeneratedList_L.end() ; B != E;) {
                vec.push_back("-L");
                vec.push_back(*B);
                ++B;
            }
        }
        if (!AutoGeneratedList_l.empty()) {
            for (cl::list<std::string>::iterator B = AutoGeneratedList_l.begin(),
            E = AutoGeneratedList_l.end() ; B != E;) {
                vec.push_back("-l");
                vec.push_back(*B);
                ++B;
            }
        }
        if (!AutoGeneratedList_Wl_comma_.empty()) {
            std::copy(AutoGeneratedList_Wl_comma_.begin(), AutoGeneratedList_Wl_comma_.end(), std::back_inserter(vec));
        }

        std::string out_file = OutFilename(inFile,
            TempDir, stop_compilation, output_suffix).str();

        vec[out_file_index] = out_file;
        return Action(cmd, vec, stop_compilation, out_file);
    }

};
const char* llvm_ld::InputLanguages_[] = {"object-code", 0};

class Edge0: public Edge {
public:
    Edge0() : Edge("clang_c") {}

    unsigned Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (AutoGeneratedSwitch_clang) {
            ret += 2;
        }
        return ret;
    };

};

class Edge1: public Edge {
public:
    Edge1() : Edge("clang_cpp") {}

    unsigned Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (AutoGeneratedSwitch_clang) {
            ret += 2;
        }
        return ret;
    };

};

class Edge2: public Edge {
public:
    Edge2() : Edge("clang_objective_c") {}

    unsigned Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (AutoGeneratedSwitch_clang) {
            ret += 2;
        }
        return ret;
    };

};

class Edge3: public Edge {
public:
    Edge3() : Edge("clang_objective_cpp") {}

    unsigned Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (AutoGeneratedSwitch_clang) {
            ret += 2;
        }
        return ret;
    };

};

class Edge8: public Edge {
public:
    Edge8() : Edge("as") {}

    unsigned Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (AutoGeneratedSwitch_clang) {
            ret += 2;
        }
        return ret;
    };

};

void PopulateCompilationGraphLocal(CompilationGraph& G) {
    G.insertNode(new as());
    G.insertNode(new clang_c());
    G.insertNode(new clang_cpp());
    G.insertNode(new clang_objective_c());
    G.insertNode(new clang_objective_cpp());
    G.insertNode(new llvm_ld());

    G.insertEdge("root", new Edge0());
    G.insertEdge("root", new Edge1());
    G.insertEdge("root", new Edge2());
    G.insertEdge("root", new Edge3());
    G.insertEdge("clang_c", new SimpleEdge("llc"));
    G.insertEdge("clang_cpp", new SimpleEdge("llc"));
    G.insertEdge("clang_objective_c", new SimpleEdge("llc"));
    G.insertEdge("clang_objective_cpp", new SimpleEdge("llc"));
    G.insertEdge("llc", new Edge8());
    G.insertEdge("as", new SimpleEdge("llvm_ld"));
}

struct Plugin : public llvmc::BasePlugin {

    int Priority() const { return 1; }

    void PreprocessOptions() const
    { PreprocessOptionsLocal(); }

    void PopulateLanguageMap(LanguageMap& langMap) const
    { PopulateLanguageMapLocal(langMap); }

    void PopulateCompilationGraph(CompilationGraph& graph) const
    { PopulateCompilationGraphLocal(graph); }
};

static llvmc::RegisterPlugin<Plugin> RP;

} // End anonymous namespace.

namespace llvmc {
LLVMC_FORCE_LINKAGE_DECL(LLVMC_PLUGIN_NAME) {}
}
